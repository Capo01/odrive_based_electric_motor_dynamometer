// Odrive data collection sketch.
// Takes input data from HX711 load cell amplifier, ACS714 hall effect current sensor and CJMCU-ADS1115 16B bit ADC Development Board
// and writes it to multi-use multi-use variables (MUV)on the odrive.
// See this fork of the odrive firmware for MUV changes https://github.com/Capo01/ODrive
// R. Parsons 13.04.19

// *****************  Odrive UART Set-up *******************
// Required to transmit data to odrive over UART to Odrive.

#include <SoftwareSerial.h> // included with the Arduino IDE.
#include <ODriveArduino.h> //https://github.com/madcowswe/ODrive/tree/master/Arduino/ODriveArduino

// Odrive UART Printing with stream operator
template<class T> inline Print& operator <<(Print &obj,     T arg) { obj.print(arg);    return obj; }
template<>        inline Print& operator <<(Print &obj, float arg) { obj.print(arg, 4); return obj; }

// Serial to the ODrive
SoftwareSerial odrive_serial(19, 18); //RX (ODrive TX), TX (ODrive RX). Pins 18 and 19 are for RX and TX for Arduino Mega only.
// Note: you must also connect GND on ODrive to GND on Arduino!

// ODrive object
ODriveArduino odrive(odrive_serial);

const long interval2 = 10; // Load cell outputs maximum of 80 SPS (every 12 ms)
unsigned long previousMillis2 = 0; 

// *****************  HX711 Load-cell set-up *******************
// required to cut trace on HX711 breakout board for 80SPS https://www.reddit.com/r/arduino/comments/6prhs2/hx711_sample_rate/

#include "HX711.h" //https://github.com/bogde/HX711

// HX711 circuit wiring
const int LOADCELL_DOUT_PIN = 22;
const int LOADCELL_SCK_PIN = 24;

HX711 scale;
unsigned long previousMillis = 0; 
const long interval = 12; // Load cell outputs maximum of 80 SPS (every 12 ms)

// *****************  Running median set-up *******************
// The large amount of EMI generated by the Odrive produces periodic spikes in the readings
// The use of the running median library helps filter out these spikes.

#include <RunningMedian.h> //https://github.com/RobTillaart/Arduino/tree/master/libraries/RunningMedian

RunningMedian samples = RunningMedian(10);  // RunningMedian(10) = median of 10 individual samples
RunningMedian current = RunningMedian(50); // RunningMedian(10) = median of 10 individual samples


// *****************  CJMCU-ADS1115 16B bit ADC set-up *******************
#include <Wire.h>
#include <Adafruit_ADS1015.h>

Adafruit_ADS1115 ads;  /* Use this for the 16-bit version */
//Adafruit_ADS1015 ads;     /* Use this for the 12-bit version */


void setup() {
  Serial.begin(115200);
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
  scale.set_scale(468.f); // determined using a known weight. See HX711 library for calibration examples.
  delay(2000); // allow some time for the reading to settle
  scale.tare();
      
  odrive_serial.begin(115200); // ODrive uses 115200 baud
  
  // The ADC input range (or gain) can be changed via the following
  // functions, but be careful never to exceed VDD +0.3V maximum, or to
  // exceed the upper and lower limits if you adjust the input range!
  // Setting these values incorrectly may destroy your ADC!
  //                                                                ADS1015  ADS1115
  //                                                                -------  -------
  //ads.setGain(GAIN_TWOTHIRDS);    // 2/3x gain +/- 6.144V  1 bit = 3mV      0.1875mV (default)
  // ads.setGain(GAIN_ONE);         // 1x gain   +/- 4.096V  1 bit = 2mV      0.125mV
  // ads.setGain(GAIN_TWO);         // 2x gain   +/- 2.048V  1 bit = 1mV      0.0625mV
  // ads.setGain(GAIN_FOUR);        // 4x gain   +/- 1.024V  1 bit = 0.5mV    0.03125mV
  // ads.setGain(GAIN_EIGHT);       // 8x gain   +/- 0.512V  1 bit = 0.25mV   0.015625mV
   ads.setGain(GAIN_SIXTEEN);       // 16x gain  +/- 0.256V  1 bit = 0.125mV  0.0078125mV

  ads.begin();
  }

void loop() {

  // read load cell value, filter it and convert to N.mm
  unsigned long currentMillis = millis();
  unsigned long currentMillis2 = millis();

  if (currentMillis - previousMillis >= interval) {
    // Read the load cell only once every interval.
    previousMillis = currentMillis;
    long x = scale.get_units(1);
    samples.add(x);
  }
  
  float m = samples.getMedian();
  float torque = -m * 0.009807 * 0.1 * 1000; // Convert mass in grams to N.m
  //Serial.print("Torque (N.mm): ");


  // read current sensor voltage
  int16_t curren_shunt_reading;
  curren_shunt_reading = ads.readADC_Differential_2_3();
  
  // filter the reading
  current.add(curren_shunt_reading);
  float curren_shunt_reading_median = current.getMedian();
  
  //convert to mA
  float multiplier = 0.0078125F; //* ADS1115  16 x gain  +/- 0.256V  1 bit = 0.125mV  0.0078125mV
  float correction_factor = 2.41; // Current shunt reads non-zero even with zero current..
  float correction_scaler = 1.102; // Correct for error in the current shun as compared to a multimeter.
  float voltage = (curren_shunt_reading_median * multiplier) + correction_factor;
  float current =((( voltage / 75 ) * 20000)) * correction_scaler; // 75 mV for 20A on current shunt.

  //for serial plotter
//Serial.println(voltage);
  Serial.print(torque);
  Serial.print(" ");
  Serial.println(current);

  // write values to Odrive using UART
  // note that custom odrive firmware is required to create the new variables. Refer to this fork https://github.com/Capo01/ODrive
  if (currentMillis2 - previousMillis2 >= interval2) {
        // Print to odrive only once every interval.
    previousMillis2 = currentMillis;
    odrive_serial << "w axis0.muv1 " << torque << '\n';
    odrive_serial << "w axis0.muv2 " << current << '\n';
  }
  }
